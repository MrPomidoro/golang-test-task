package job

const SlowTaskMissingNumbers = `
Возможное решение задачи предполагает следующие шаги:

Создать новый массив:
Создайте массив размером N+1 (пусть его название будет count), где N - это размер входного массива. Инициализируйте все значения массива нулями.

Подсчитать вхождения чисел:
Пройдите по входному массиву и увеличивайте значение элемента в массиве count по индексу, соответствующему числу из входного массива. Таким образом, элемент count[i] будет содержать количество вхождений числа i в исходном массиве.

Найти пропущенные числа:
Теперь пройдите по массиву count начиная с первого элемента. Если значение count[i] равно нулю, это означает, что число i отсутствует в исходном массиве. Это число следует добавить в список пропущенных чисел.

Давайте иллюстрируем это решение на конкретном примере.

Входной массив: [4, 3, 2, 7, 8, 2, 3, 1]. Его размер N=8. Создаем массив count размером 9 (N+1) и инициализируем его нулями: [0, 0, 0, 0, 0, 0, 0, 0, 0].

Теперь идем по входному массиву и увеличиваем значения в массиве count по соответствующим индексам: [0, 1, 2, 2, 1, 0, 0, 1, 1].

Теперь мы видим, что числа 1, 2, 3, 4, 7 и 8 встречаются в исходном массиве (потому что count[i] для этих чисел больше 0). Но числа 5 и 6 отсутствуют (потому что count[5] и count[6] равны нулю). Значит, 5 и 6 - это пропущенные числа.

Это решение работает за O(N) времени, где N - размер входного массива, поскольку мы делаем два прохода по массиву - один для подсчета вхождений и один для поиска пропущенных чисел.
`
